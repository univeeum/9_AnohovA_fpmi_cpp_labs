#include <iostream>
#include <numeric>

int Gcd(int a, int b) {
    while (a * b) {
        int rem = a % b;
        a = b;
        b = rem;
    }
    return std::max(a, b);
}

void TryRead(int& number) {
    if (!(std::cin >> number)) {
        std::cout << "Fail on reading the number" << std::endl;
        exit(0);
    }
}

int main() {
    int a, b;
    
    std::cout << "Enter a: ";
    TryRead(a);

    std::cout << "Enter b: ";
    TryRead(b);

    if (a <= 0 || b <= 0) {
        std::cout << "Numbers should be positive" << std::endl;
        return 0;
    }

    int gcd1 = Gcd(a, b);
    int gcd2 = std::gcd(a, b);
    
    if (gcd1 != gcd2) {
        std::cout << "Shit, you broke my program :{" << std::endl;
        return 1;
    } else {
        std::cout << "Try again..." << std::endl;
    }

    return 0;
}

/*

Код может работать неправильно из за условия в цикле while (a * b) переполнение происходит и если переполнение равно 0 на какой нибудь итерации цикла то функция вернет неправильный ответ. 
Как нам получить 0 при переполнении? Мы знаем, что при переполнении результат вычисляется по модулю 2^32 (на большинстве систем) то есть результат переполнения есть (a*b) mod 2^32 и если произведение делится на 2^32 то результат (a*b) mod 2^32 = 0 то есть цикл while не выполняет свою итерацию и скорее всего (если случайно не окажется gcd != max(a, b) например для a = 2^16 и b = 2^16) функция gcd1 выведет неправильный ответ. Достаточно просто взять такие a = 2^t и b = 2^(32-t).  

Взлом программы:

Enter a: 4096
Enter b: 1048576
Shit, you broke my program :{

Enter a: 4
Enter b: 1073741824
Shit, you broke my program :{

Enter a: 16
Enter b: 268435456
Shit, you broke my program :{

так же заметим что подойдут такие a и b, что промежуточные значения этих переменных в цикле при перемножении переполняются и дают 0, к примеру:
a = 2^28 + 2^4
b = 2^28
Enter a: 268435456
Enter b: 268435472
Shit, you broke my program :{

На первой итерации все нормально. На второй итерации a = 2^28, b = 2^4 и на этой итерации функция ломается, так как a * b mod INT_MAX = 0.

Теоретические вопросы к задаче 1.3.2 
1) Если переписать более понятным языком условие "первой" пары элементов: сначала сравниваем первый компонент x.
Если он меньше - пара меньше независимо от второго. Только если x равны, сравниваем y
Тогда подбором можно быстро выяснить что такая пара - a: 4 и b: 1073741824. 

2) Множество пар {a, b} можно описать условиями:
Формальное описание множества ответов:
W = ({a, b} | ∃k: a_k != b_k && a_k != 0 && b_k != 0 && a_k * b_k mod INT_MAX == 0), где a_k, b_k промежуточные значения цикла while функции Gcd. 

Так же обратим внимание, что переполнение типа int является undefined behaviour, что означает, что мы можем обобщить наше множество таким образом:
W' = ({a, b} | ∃k: a_k * b_k > INT_MAX), где a_k, b_k промежуточные значения цикла while функции Gcd. 

3) Представим, что существуют такие a и b, которые не принадлежат W' и Gcd(a, b) != std::gcd(a, b).
Тогда это не возможно по алгоритму Евклида (НОД(a,b) == НОД(a-b, b)).

*/