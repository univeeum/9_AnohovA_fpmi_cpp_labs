#include <iostream>
#include <numeric>

int Gcd(int a, int b) {
    while (a * b) {
        int rem = a % b;
        a = b;
        b = rem;
    }
    return std::max(a, b);
}

void TryRead(int& number) {
    if (!(std::cin >> number)) {
        std::cout << "Fail on reading the number" << std::endl;
        exit(0);
    }
}

int main() {
    int a, b;
    
    std::cout << "Enter a: ";
    TryRead(a);

    std::cout << "Enter b: ";
    TryRead(b);

    //std::cout << a * b << std::endl;

    if (a <= 0 || b <= 0) {
        std::cout << "Numbers should be positive" << std::endl;
        return 0;
    }

    int gcd1 = Gcd(a, b);
    int gcd2 = std::gcd(a, b);
    
    if (gcd1 != gcd2) {
        std::cout << "Shit, you broke my program :{" << std::endl;
        return 1;
    } else {
        std::cout << "Try again..." << std::endl;
    }

    return 0;
}

/*

Код может работать неправильно из за условия в цикле while (a * b) переполнение происходит и если переполнение равно 0 то
мы получим неправильный ответ, тк цикл не выполнит ни одной итерации. Gcd сразу вернет max (a, b) и почти всегда это неверный ответ.
Как нам получить 0 при переполнении? Мы знаем, что при переполнении результат вычисляется по модулю 2^32 (на большинстве систем) то есть 
результат переполнения есть (a*b) mod 2^32 и если произведение делится на 2^32 то результат (a*b) mod 2^32 = 0 то есть цикл 
while не выполняет свою итерацию и скорее всего (если случайно не окажется gcd != max(a, b) например для a = 2^16 и b = 2^16) 
функция gcd1 выведет неправильный ответ. Достаточно просто взять такие a = 2^t и b = 2^(32-t).  

Взлом программы:

Enter a: 4096
Enter b: 1048576
Shit, you broke my program :{

Enter a: 4
Enter b: 1073741824
Shit, you broke my program :{

Enter a: 16
Enter b: 268435456
Shit, you broke my program :{

Теоретические вопросы к задаче 1.3.2 
1) Если переписать более понятным языком условие "первой" пары элементов: сначала сравниваем первый компонент x.
Если он меньше - пара меньше независимо от второго. Только если x равны, сравниваем y
Тогда подбором можно быстро выяснить что такая пара - a: 4 и b: 1073741824. 

2) Множество пар (a, b) можно описать условиями:
1. a, b ∈ N, 1 <= a, b <= INT_MAX
2. a != b
3. (a * b) mod 2^32 = 0

3) Разные значения у функций Gcd и std::gcd происходит только когда цикл в функции Gcd не выполняется (при a*b=0) где a != b
Для натуральных чисел a*b=0 возможно только при переполнении, когда произведение кратно 2^32. Получается описанное множество 
является полным.

*/